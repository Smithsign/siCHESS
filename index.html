<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>siCHESS - Practice Mode</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.2/chess.js"></script>
    <style>
        :root {
            --orange-light: #ffb347;
            --orange-med: #ff8c00;
            --orange-dark: #ff6b00;
            --white: #ffffff;
            --black: #222222;
            --highlight: rgba(255, 140, 0, 0.5);
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #fff8f0, #ffe8d1);
            margin: 0;
            padding: 20px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            color: var(--black);
        }
        
        h1 {
            color: var(--orange-dark);
            text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
            margin-bottom: 10px;
        }
        
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            width: 100%;
            max-width: 800px;
        }
        
        .menu-screen {
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        
        .start-btn {
            padding: 12px 30px;
            border: none;
            border-radius: 25px;
            background: linear-gradient(to right, var(--orange-med), var(--orange-dark));
            color: white;
            font-weight: bold;
            font-size: 1.2rem;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(255, 107, 0, 0.3);
            transition: all 0.3s;
        }
        
        .start-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(255, 107, 0, 0.4);
        }
        
        .board-container {
            position: relative;
            width: 100%;
            max-width: 500px;
            aspect-ratio: 1/1;
            box-shadow: 0 10px 20px rgba(0,0,0,0.1);
            border-radius: 8px;
            overflow: hidden;
            display: none;
        }
        
        #board {
            width: 100%;
            height: 100%;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
        }
        
        .square {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
        }
        
        .white {
            background-color: var(--white);
        }
        
        .black {
            background-color: var(--orange-light);
        }
        
        .piece {
            width: 80%;
            height: 80%;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            z-index: 10;
        }
        
        .selected {
            background-color: var(--highlight);
        }
        
        .valid-move {
            position: absolute;
            width: 30%;
            height: 30%;
            background-color: var(--highlight);
            border-radius: 50%;
            z-index: 5;
        }
        
        .capture-move {
            position: absolute;
            width: 80%;
            height: 80%;
            border: 4px solid var(--highlight);
            border-radius: 50%;
            box-sizing: border-box;
            z-index: 5;
        }
        
        .timer-container {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 500px;
            display: none;
        }
        
        .timer {
            background: linear-gradient(to right, var(--orange-light), var(--orange-med));
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 1.2rem;
            font-weight: bold;
            box-shadow: 0 4px 8px rgba(255, 140, 0, 0.2);
            min-width: 100px;
            text-align: center;
        }
        
        .timer.low-time {
            animation: pulse 1s infinite;
        }
        
        .current-turn {
            font-size: 1.2rem;
            font-weight: bold;
            color: var(--orange-dark);
            margin-bottom: 10px;
        }
        
        @keyframes pulse {
            0% { background: linear-gradient(to right, var(--orange-light), var(--orange-med)); }
            50% { background: linear-gradient(to right, #ff5e5e, #ff0000); }
            100% { background: linear-gradient(to right, var(--orange-light), var(--orange-med)); }
        }
        
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }
        
        .modal.active {
            opacity: 1;
            pointer-events: all;
        }
        
        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            max-width: 400px;
            width: 90%;
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
            transform: translateY(-20px);
            transition: transform 0.3s;
        }
        
        .modal.active .modal-content {
            transform: translateY(0);
        }
        
        .modal h2 {
            color: var(--orange-dark);
            margin-bottom: 20px;
        }
        
        .modal p {
            margin-bottom: 25px;
            font-size: 1.1rem;
        }
        
        .modal-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
        }
        
        .modal-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 25px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .primary-btn {
            background: linear-gradient(to right, var(--orange-light), var(--orange-med));
            color: white;
        }
        
        .secondary-btn {
            background: #f0f0f0;
            color: var(--black);
        }
        
        .modal-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        
        @media (max-width: 600px) {
            .timer-container {
                flex-direction: column;
                gap: 10px;
            }
            
            .timer {
                width: 100%;
                box-sizing: border-box;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>siCHESS üçä</h1>
        <h2>Practice Mode</h2>
        
        <div class="menu-screen" id="menu-screen">
            <button class="start-btn" id="start-btn">Start Practice</button>
        </div>
        
        <div class="current-turn" id="current-turn" style="display: none;">White's Turn</div>
        
        <div class="board-container" id="board-container">
            <div id="board"></div>
        </div>
        
        <div class="timer-container" id="timer-container">
            <div class="timer" id="white-timer">5:00</div>
            <div class="timer" id="black-timer">5:00</div>
        </div>
    </div>
    
    <div class="modal" id="game-over-modal">
        <div class="modal-content">
            <h2 id="modal-title">Game Over</h2>
            <p id="modal-message"></p>
            <div class="modal-buttons">
                <button class="modal-btn primary-btn" id="try-again-btn">Try Again</button>
                <button class="modal-btn secondary-btn" id="share-btn">Share on X</button>
            </div>
        </div>
    </div>
    
    <script>
        // Game state
        let game = new Chess();
        let selectedSquare = null;
        let validMoves = [];
        let whiteTime = 5 * 60;
        let blackTime = 5 * 60;
        let whiteTimerInterval = null;
        let blackTimerInterval = null;
        let gameActive = false;
        
        // DOM elements
        const boardElement = document.getElementById('board');
        const whiteTimerElement = document.getElementById('white-timer');
        const blackTimerElement = document.getElementById('black-timer');
        const startBtn = document.getElementById('start-btn');
        const menuScreen = document.getElementById('menu-screen');
        const boardContainer = document.getElementById('board-container');
        const timerContainer = document.getElementById('timer-container');
        const currentTurnElement = document.getElementById('current-turn');
        const gameOverModal = document.getElementById('game-over-modal');
        const modalTitle = document.getElementById('modal-title');
        const modalMessage = document.getElementById('modal-message');
        const tryAgainBtn = document.getElementById('try-again-btn');
        const shareBtn = document.getElementById('share-btn');
        
        // Initialize the board
        function initBoard() {
            boardElement.innerHTML = '';
            
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    const square = document.createElement('div');
                    square.className = `square ${(i + j) % 2 === 0 ? 'white' : 'black'}`;
                    square.dataset.row = i;
                    square.dataset.col = j;
                    square.dataset.square = `${String.fromCharCode(97 + j)}${8 - i}`;
                    
                    square.addEventListener('click', () => handleSquareClick(square));
                    
                    boardElement.appendChild(square);
                }
            }
            
            updateBoard();
        }
        
        // Update the board display
        function updateBoard() {
            // Clear previous highlights and valid moves
            document.querySelectorAll('.selected, .valid-move, .capture-move').forEach(el => {
                el.classList.remove('selected', 'valid-move', 'capture-move');
                const moveIndicator = el.querySelector('.valid-move, .capture-move');
                if (moveIndicator) el.removeChild(moveIndicator);
            });
            
            // Update pieces
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    const squareNotation = `${String.fromCharCode(97 + j)}${8 - i}`;
                    const piece = game.get(squareNotation);
                    const squareElement = document.querySelector(`[data-square="${squareNotation}"]`);
                    
                    // Clear previous piece
                    const existingPiece = squareElement.querySelector('.piece');
                    if (existingPiece) squareElement.removeChild(existingPiece);
                    
                    // Add new piece if present
                    if (piece) {
                        const pieceElement = document.createElement('div');
                        pieceElement.className = 'piece';
                        pieceElement.style.backgroundImage = `url('https://images.chesscomfiles.com/chess-themes/pieces/neo/150/${piece.color}${piece.type}.png')`;
                        squareElement.appendChild(pieceElement);
                    }
                }
            }
            
            // Highlight selected square and valid moves
            if (selectedSquare) {
                const squareElement = document.querySelector(`[data-square="${selectedSquare}"]`);
                if (squareElement) {
                    squareElement.classList.add('selected');
                    
                    validMoves.forEach(move => {
                        if (move.from === selectedSquare) {
                            const targetSquare = document.querySelector(`[data-square="${move.to}"]`);
                            if (targetSquare) {
                                const moveIndicator = document.createElement('div');
                                moveIndicator.className = game.get(move.to) ? 'capture-move' : 'valid-move';
                                targetSquare.appendChild(moveIndicator);
                            }
                        }
                    });
                }
            }
            
            // Update turn indicator
            currentTurnElement.textContent = game.turn() === 'w' ? "White's Turn" : "Black's Turn";
        }
        
        // Handle square clicks
        function handleSquareClick(squareElement) {
            if (!gameActive) return;
            
            const square = squareElement.dataset.square;
            const piece = game.get(square);
            
            // If no square is selected and the clicked square has a piece of the current turn's color, select it
            if (!selectedSquare && piece && piece.color === game.turn()) {
                selectedSquare = square;
                validMoves = game.moves({
                    square: square,
                    verbose: true
                });
                updateBoard();
                return;
            }
            
            // If a square is already selected
            if (selectedSquare) {
                // If clicking on the same square, deselect it
                if (square === selectedSquare) {
                    selectedSquare = null;
                    validMoves = [];
                    updateBoard();
                    return;
                }
                
                // If clicking on another piece of the same color, select that piece instead
                if (piece && piece.color === game.turn()) {
                    selectedSquare = square;
                    validMoves = game.moves({
                        square: square,
                        verbose: true
                    });
                    updateBoard();
                    return;
                }
                
                // Check if the move is valid
                const move = validMoves.find(m => m.to === square);
                
                if (move) {
                    makeMove(move);
                }
            }
        }
        
        // Make a move
        function makeMove(move) {
            // Stop the current player's timer
            if (game.turn() === 'w') stopWhiteTimer();
            else stopBlackTimer();
            
            game.move(move);
            selectedSquare = null;
            validMoves = [];
            updateBoard();
            
            // Check for game over
            if (game.isGameOver()) {
                endGame();
                return;
            }
            
            // Switch turns and start the other player's timer
            if (game.turn() === 'w') {
                startWhiteTimer();
            } else {
                startBlackTimer();
            }
        }
        
        // Timer functions
        function startWhiteTimer() {
            stopBlackTimer();
            whiteTimerInterval = setInterval(() => {
                whiteTime--;
                updateTimers();
                
                if (whiteTime <= 0) {
                    stopWhiteTimer();
                    endGame(false); // Black wins (false = white didn't win)
                }
                
                if (whiteTime <= 30) {
                    whiteTimerElement.classList.add('low-time');
                }
            }, 1000);
        }
        
        function stopWhiteTimer() {
            if (whiteTimerInterval) {
                clearInterval(whiteTimerInterval);
                whiteTimerInterval = null;
            }
            whiteTimerElement.classList.remove('low-time');
        }
        
        function startBlackTimer() {
            stopWhiteTimer();
            blackTimerInterval = setInterval(() => {
                blackTime--;
                updateTimers();
                
                if (blackTime <= 0) {
                    stopBlackTimer();
                    endGame(true); // White wins (true = white won)
                }
            }, 1000);
        }
        
        function stopBlackTimer() {
            if (blackTimerInterval) {
                clearInterval(blackTimerInterval);
                blackTimerInterval = null;
            }
        }
        
        function updateTimers() {
            const whiteMinutes = Math.floor(whiteTime / 60);
            const whiteSeconds = whiteTime % 60;
            whiteTimerElement.textContent = `${whiteMinutes}:${whiteSeconds.toString().padStart(2, '0')}`;
            
            const blackMinutes = Math.floor(blackTime / 60);
            const blackSeconds = blackTime % 60;
            blackTimerElement.textContent = `${blackMinutes}:${blackSeconds.toString().padStart(2, '0')}`;
        }
        
        // Game control functions
        function startGame() {
            game = new Chess();
            selectedSquare = null;
            validMoves = [];
            whiteTime = 5 * 60;
            blackTime = 5 * 60;
            gameActive = true;
            
            // Show game elements
            menuScreen.style.display = 'none';
            boardContainer.style.display = 'block';
            timerContainer.style.display = 'flex';
            currentTurnElement.style.display = 'block';
            
            updateTimers();
            initBoard();
            startWhiteTimer(); // White starts first
        }
        
        function endGame(whiteWon = null) {
            gameActive = false;
            stopWhiteTimer();
            stopBlackTimer();
            
            if (whiteWon === null) {
                // Game ended by checkmate or draw
                if (game.isCheckmate()) {
                    whiteWon = game.turn() === 'b'; // If black's turn, white won
                } else {
                    // Draw
                    modalTitle.textContent = "Game Drawn";
                    modalMessage.textContent = "The game ended in a draw. Try again!";
                }
            }
            
            if (whiteWon !== null) {
                if (whiteWon) {
                    modalTitle.textContent = "White Wins!";
                    modalMessage.textContent = "üéâ White player wins! üçä";
                } else {
                    modalTitle.textContent = "Black Wins!";
                    modalMessage.textContent = "üéâ Black player wins! üçä";
                }
            }
            
            gameOverModal.classList.add('active');
        }
        
        function returnToMenu() {
            gameActive = false;
            stopWhiteTimer();
            stopBlackTimer();
            
            // Show menu elements
            menuScreen.style.display = 'flex';
            boardContainer.style.display = 'none';
            timerContainer.style.display = 'none';
            currentTurnElement.style.display = 'none';
        }
        
        // Event listeners
        startBtn.addEventListener('click', startGame);
        
        tryAgainBtn.addEventListener('click', () => {
            gameOverModal.classList.remove('active');
            startGame();
        });
        
        shareBtn.addEventListener('click', () => {
            let text;
            if (modalTitle.textContent.includes("White")) {
                text = "I just won as White in siCHESS Practice Mode! üçä #siCHESS";
            } else if (modalTitle.textContent.includes("Black")) {
                text = "I just won as Black in siCHESS Practice Mode! üçä #siCHESS";
            } else {
                text = "I played a draw in siCHESS Practice Mode! üçä #siCHESS";
            }
            
            const url = "https://twitter.com/intent/tweet?text=" + encodeURIComponent(text);
            window.open(url, '_blank');
        });
    </script>
</body>
</html>
