<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>siCHESS - Orange Themed Chess</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.2/chess.js"></script>
    <style>
        :root {
            --orange-light: #ffb347;
            --orange-med: #ff8c00;
            --orange-dark: #ff6b00;
            --white: #ffffff;
            --black: #222222;
            --highlight: rgba(255, 140, 0, 0.5);
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #fff8f0, #ffe8d1);
            margin: 0;
            padding: 20px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            color: var(--black);
        }
        
        h1 {
            color: var(--orange-dark);
            text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
            margin-bottom: 10px;
        }
        
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            width: 100%;
            max-width: 800px;
        }
        
        .difficulty-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .difficulty-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 25px;
            background: linear-gradient(to right, var(--orange-light), var(--orange-med));
            color: white;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(255, 140, 0, 0.2);
            transition: all 0.3s;
        }
        
        .difficulty-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(255, 140, 0, 0.3);
        }
        
        .difficulty-btn.active {
            background: linear-gradient(to right, var(--orange-med), var(--orange-dark));
            box-shadow: 0 4px 8px rgba(255, 107, 0, 0.3);
        }
        
        .board-container {
            position: relative;
            width: 100%;
            max-width: 500px;
            aspect-ratio: 1/1;
            box-shadow: 0 10px 20px rgba(0,0,0,0.1);
            border-radius: 8px;
            overflow: hidden;
        }
        
        #board {
            width: 100%;
            height: 100%;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
        }
        
        .square {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
        }
        
        .white {
            background-color: var(--white);
        }
        
        .black {
            background-color: var(--orange-light);
        }
        
        .piece {
            width: 80%;
            height: 80%;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            z-index: 10;
        }
        
        .selected {
            background-color: var(--highlight);
        }
        
        .valid-move {
            position: absolute;
            width: 30%;
            height: 30%;
            background-color: var(--highlight);
            border-radius: 50%;
            z-index: 5;
        }
        
        .capture-move {
            position: absolute;
            width: 80%;
            height: 80%;
            border: 4px solid var(--highlight);
            border-radius: 50%;
            box-sizing: border-box;
            z-index: 5;
        }
        
        .timer-container {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 500px;
        }
        
        .timer {
            background: linear-gradient(to right, var(--orange-light), var(--orange-med));
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 1.2rem;
            font-weight: bold;
            box-shadow: 0 4px 8px rgba(255, 140, 0, 0.2);
            min-width: 100px;
            text-align: center;
        }
        
        .timer.low-time {
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0% { background: linear-gradient(to right, var(--orange-light), var(--orange-med)); }
            50% { background: linear-gradient(to right, #ff5e5e, #ff0000); }
            100% { background: linear-gradient(to right, var(--orange-light), var(--orange-med)); }
        }
        
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }
        
        .modal.active {
            opacity: 1;
            pointer-events: all;
        }
        
        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            max-width: 400px;
            width: 90%;
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
            transform: translateY(-20px);
            transition: transform 0.3s;
        }
        
        .modal.active .modal-content {
            transform: translateY(0);
        }
        
        .modal h2 {
            color: var(--orange-dark);
            margin-bottom: 20px;
        }
        
        .modal p {
            margin-bottom: 25px;
            font-size: 1.1rem;
        }
        
        .modal-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
        }
        
        .modal-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 25px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .primary-btn {
            background: linear-gradient(to right, var(--orange-light), var(--orange-med));
            color: white;
        }
        
        .secondary-btn {
            background: #f0f0f0;
            color: var(--black);
        }
        
        .modal-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        
        @media (max-width: 600px) {
            .difficulty-selector {
                flex-direction: column;
                width: 100%;
            }
            
            .difficulty-btn {
                width: 100%;
            }
            
            .timer-container {
                flex-direction: column;
                gap: 10px;
            }
            
            .timer {
                width: 100%;
                box-sizing: border-box;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>siCHESS ï¿½</h1>
        
        <div class="difficulty-selector">
            <button class="difficulty-btn" data-difficulty="easy">Easy</button>
            <button class="difficulty-btn" data-difficulty="medium">Medium</button>
            <button class="difficulty-btn" data-difficulty="extreme">Extreme</button>
        </div>
        
        <div class="board-container">
            <div id="board"></div>
        </div>
        
        <div class="timer-container">
            <div class="timer" id="player-timer">5:00</div>
            <div class="timer" id="ai-timer">5:00</div>
        </div>
    </div>
    
    <div class="modal" id="game-over-modal">
        <div class="modal-content">
            <h2 id="modal-title">Game Over</h2>
            <p id="modal-message"></p>
            <div class="modal-buttons">
                <button class="modal-btn primary-btn" id="try-again-btn">Try Again</button>
                <button class="modal-btn secondary-btn" id="share-btn">Share on X</button>
            </div>
        </div>
    </div>
    
    <script>
        // Game state
        let game = new Chess();
        let selectedSquare = null;
        let validMoves = [];
        let difficulty = 'medium';
        let playerTime = 5 * 60; // 5 minutes in seconds
        let aiTime = 5 * 60;
        let playerTimerInterval = null;
        let aiTimerInterval = null;
        let isPlayerTurn = true;
        let gameActive = false;
        
        // DOM elements
        const boardElement = document.getElementById('board');
        const playerTimerElement = document.getElementById('player-timer');
        const aiTimerElement = document.getElementById('ai-timer');
        const difficultyButtons = document.querySelectorAll('.difficulty-btn');
        const gameOverModal = document.getElementById('game-over-modal');
        const modalTitle = document.getElementById('modal-title');
        const modalMessage = document.getElementById('modal-message');
        const tryAgainBtn = document.getElementById('try-again-btn');
        const shareBtn = document.getElementById('share-btn');
        
        // Initialize the board
        function initBoard() {
            boardElement.innerHTML = '';
            
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    const square = document.createElement('div');
                    square.className = `square ${(i + j) % 2 === 0 ? 'white' : 'black'}`;
                    square.dataset.row = i;
                    square.dataset.col = j;
                    square.dataset.square = `${String.fromCharCode(97 + j)}${8 - i}`;
                    
                    square.addEventListener('click', () => handleSquareClick(square));
                    
                    boardElement.appendChild(square);
                }
            }
            
            updateBoard();
        }
        
        // Update the board display based on game state
        function updateBoard() {
            // Clear previous highlights and valid moves
            document.querySelectorAll('.selected, .valid-move, .capture-move').forEach(el => {
                el.classList.remove('selected', 'valid-move', 'capture-move');
                const moveIndicator = el.querySelector('.valid-move, .capture-move');
                if (moveIndicator) {
                    el.removeChild(moveIndicator);
                }
            });
            
            // Update pieces
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    const squareNotation = `${String.fromCharCode(97 + j)}${8 - i}`;
                    const piece = game.get(squareNotation);
                    const squareElement = document.querySelector(`[data-square="${squareNotation}"]`);
                    
                    // Clear previous piece
                    const existingPiece = squareElement.querySelector('.piece');
                    if (existingPiece) {
                        squareElement.removeChild(existingPiece);
                    }
                    
                    // Add new piece if present
                    if (piece) {
                        const pieceElement = document.createElement('div');
                        pieceElement.className = 'piece';
                        pieceElement.style.backgroundImage = `url('https://images.chesscomfiles.com/chess-themes/pieces/neo/150/${piece.color}${piece.type}.png')`;
                        squareElement.appendChild(pieceElement);
                    }
                }
            }
            
            // Highlight selected square and valid moves
            if (selectedSquare) {
                const squareElement = document.querySelector(`[data-square="${selectedSquare}"]`);
                if (squareElement) {
                    squareElement.classList.add('selected');
                    
                    validMoves.forEach(move => {
                        if (move.from === selectedSquare) {
                            const targetSquare = document.querySelector(`[data-square="${move.to}"]`);
                            if (targetSquare) {
                                const moveIndicator = document.createElement('div');
                                const targetPiece = game.get(move.to);
                                
                                if (targetPiece) {
                                    moveIndicator.className = 'capture-move';
                                } else {
                                    moveIndicator.className = 'valid-move';
                                }
                                
                                targetSquare.appendChild(moveIndicator);
                            }
                        }
                    });
                }
            }
        }
        
        // Handle square clicks
        function handleSquareClick(squareElement) {
            if (!gameActive || !isPlayerTurn) return;
            
            const square = squareElement.dataset.square;
            const piece = game.get(square);
            
            // If no square is selected and the clicked square has a player's piece, select it
            if (!selectedSquare && piece && piece.color === 'w') {
                selectedSquare = square;
                validMoves = game.moves({
                    square: square,
                    verbose: true
                });
                updateBoard();
                return;
            }
            
            // If a square is already selected
            if (selectedSquare) {
                // If clicking on the same square, deselect it
                if (square === selectedSquare) {
                    selectedSquare = null;
                    validMoves = [];
                    updateBoard();
                    return;
                }
                
                // If clicking on another player's piece, select that piece instead
                if (piece && piece.color === 'w') {
                    selectedSquare = square;
                    validMoves = game.moves({
                        square: square,
                        verbose: true
                    });
                    updateBoard();
                    return;
                }
                
                // Check if the move is valid
                const move = validMoves.find(m => m.to === square);
                
                if (move) {
                    makeMove(move);
                }
            }
        }
        
        // Make a move
        function makeMove(move) {
            game.move(move);
            selectedSquare = null;
            validMoves = [];
            updateBoard();
            
            // Check for game over
            if (game.isGameOver()) {
                endGame();
                return;
            }
            
            // Switch turns
            isPlayerTurn = !isPlayerTurn;
            
            if (isPlayerTurn) {
                startPlayerTimer();
                stopAITimer();
            } else {
                startAITimer();
                stopPlayerTimer();
                setTimeout(makeAIMove, 500); // Small delay for better UX
            }
        }
        
        // AI move logic
        function makeAIMove() {
            if (!gameActive || isPlayerTurn) return;
            
            let move;
            
            if (difficulty === 'easy') {
                // Easy: Random move
                const moves = game.moves();
                move = moves[Math.floor(Math.random() * moves.length)];
            } else if (difficulty === 'medium') {
                // Medium: Prefer captures and safe moves
                const moves = game.moves({verbose: true});
                
                // Find captures first
                const captures = moves.filter(m => m.captured);
                if (captures.length > 0) {
                    // Prefer higher value captures
                    captures.sort((a, b) => {
                        const aValue = getPieceValue(a.captured);
                        const bValue = getPieceValue(b.captured);
                        return bValue - aValue;
                    });
                    move = captures[0].san;
                } else {
                    // No captures, find safe moves (not leaving pieces en prise)
                    const safeMoves = moves.filter(m => {
                        const testGame = new Chess(game.fen());
                        testGame.move(m);
                        return !testGame.isCheckmate() && !isSquareAttacked(testGame, m.to, 'w');
                    });
                    
                    if (safeMoves.length > 0) {
                        move = safeMoves[Math.floor(Math.random() * safeMoves.length)].san;
                    } else {
                        // No safe moves, just pick randomly
                        move = moves[Math.floor(Math.random() * moves.length)].san;
                    }
                }
            } else {
                // Extreme: Use minimax with small depth
                move = findBestMove(2);
            }
            
            if (move) {
                const moveObj = game.move(move);
                updateBoard();
                
                // Check for game over
                if (game.isGameOver()) {
                    endGame();
                    return;
                }
                
                // Switch back to player
                isPlayerTurn = true;
                startPlayerTimer();
                stopAITimer();
            }
        }
        
        // Helper function to check if a square is attacked
        function isSquareAttacked(game, square, color) {
            const tempGame = new Chess(game.fen());
            tempGame.turn = color === 'w' ? 'b' : 'w';
            const moves = tempGame.moves({square: square, verbose: true});
            return moves.some(m => m.to === square);
        }
        
        // Piece values for medium AI
        function getPieceValue(pieceType) {
            const values = {
                'p': 1,
                'n': 3,
                'b': 3,
                'r': 5,
                'q': 9,
                'k': 0
            };
            return values[pieceType] || 0;
        }
        
        // Minimax algorithm for extreme difficulty
        function findBestMove(depth) {
            const moves = game.moves({verbose: true});
            let bestMove = null;
            let bestValue = -Infinity;
            
            for (const move of moves) {
                const testGame = new Chess(game.fen());
                testGame.move(move);
                
                const value = minimax(testGame, depth - 1, -Infinity, Infinity, false);
                
                if (value > bestValue) {
                    bestValue = value;
                    bestMove = move;
                }
            }
            
            return bestMove ? bestMove.san : moves[Math.floor(Math.random() * moves.length)].san;
        }
        
        function minimax(game, depth, alpha, beta, maximizingPlayer) {
            if (depth === 0 || game.isGameOver()) {
                return evaluateBoard(game);
            }
            
            const moves = game.moves({verbose: true});
            
            if (maximizingPlayer) {
                let maxEval = -Infinity;
                
                for (const move of moves) {
                    const testGame = new Chess(game.fen());
                    testGame.move(move);
                    
                    const eval = minimax(testGame, depth - 1, alpha, beta, false);
                    maxEval = Math.max(maxEval, eval);
                    alpha = Math.max(alpha, eval);
                    
                    if (beta <= alpha) {
                        break;
                    }
                }
                
                return maxEval;
            } else {
                let minEval = Infinity;
                
                for (const move of moves) {
                    const testGame = new Chess(game.fen());
                    testGame.move(move);
                    
                    const eval = minimax(testGame, depth - 1, alpha, beta, true);
                    minEval = Math.min(minEval, eval);
                    beta = Math.min(beta, eval);
                    
                    if (beta <= alpha) {
                        break;
                    }
                }
                
                return minEval;
            }
        }
        
        // Board evaluation function
        function evaluateBoard(game) {
            if (game.isCheckmate()) {
                return game.turn() === 'w' ? -1000 : 1000;
            }
            
            if (game.isDraw()) {
                return 0;
            }
            
            let score = 0;
            const pieceValues = {
                'p': 1, 'n': 3, 'b': 3, 'r': 5, 'q': 9, 'k': 0
            };
            
            const board = game.board();
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    const piece = board[i][j];
                    if (piece) {
                        const value = pieceValues[piece.type];
                        score += piece.color === 'w' ? value : -value;
                    }
                }
            }
            
            return score;
        }
        
        // Timer functions
        function startPlayerTimer() {
            stopPlayerTimer();
            playerTimerInterval = setInterval(() => {
                playerTime--;
                updateTimers();
                
                if (playerTime <= 0) {
                    stopPlayerTimer();
                    endGame(false);
                }
                
                if (playerTime <= 30) {
                    playerTimerElement.classList.add('low-time');
                }
            }, 1000);
        }
        
        function stopPlayerTimer() {
            if (playerTimerInterval) {
                clearInterval(playerTimerInterval);
                playerTimerInterval = null;
            }
            playerTimerElement.classList.remove('low-time');
        }
        
        function startAITimer() {
            stopAITimer();
            aiTimerInterval = setInterval(() => {
                aiTime--;
                updateTimers();
                
                if (aiTime <= 0) {
                    stopAITimer();
                    endGame(true);
                }
            }, 1000);
        }
        
        function stopAITimer() {
            if (aiTimerInterval) {
                clearInterval(aiTimerInterval);
                aiTimerInterval = null;
            }
        }
        
        function updateTimers() {
            const playerMinutes = Math.floor(playerTime / 60);
            const playerSeconds = playerTime % 60;
            playerTimerElement.textContent = `${playerMinutes}:${playerSeconds.toString().padStart(2, '0')}`;
            
            const aiMinutes = Math.floor(aiTime / 60);
            const aiSeconds = aiTime % 60;
            aiTimerElement.textContent = `${aiMinutes}:${aiSeconds.toString().padStart(2, '0')}`;
        }
        
        // Game control functions
        function startGame() {
            game = new Chess();
            selectedSquare = null;
            validMoves = [];
            playerTime = 5 * 60;
            aiTime = 5 * 60;
            isPlayerTurn = true;
            gameActive = true;
            
            updateTimers();
            initBoard();
            startPlayerTimer();
        }
        
        function endGame(playerWon = null) {
            gameActive = false;
            stopPlayerTimer();
            stopAITimer();
            
            if (playerWon === null) {
                // Game ended by checkmate or draw
                if (game.isCheckmate()) {
                    playerWon = game.turn() === 'b'; // If black's turn, white won
                } else {
                    // Draw
                    modalTitle.textContent = "Game Drawn";
                    modalMessage.textContent = "The game ended in a draw. Try again!";
                }
            } else if (playerWon) {
                // Player won on time
                modalTitle.textContent = "Victory!";
                modalMessage.textContent = "ð You won and earned 520 ORANGES! ð";
            } else {
                // AI won on time
                modalTitle.textContent = "Game Over";
                modalMessage.textContent = "Time's up! Try again and claim those ORANGES!";
            }
            
            if (playerWon !== null) {
                gameOverModal.classList.add('active');
            }
        }
        
        // Event listeners
        difficultyButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                difficultyButtons.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                difficulty = btn.dataset.difficulty;
            });
        });
        
        tryAgainBtn.addEventListener('click', () => {
            gameOverModal.classList.remove('active');
            startGame();
        });
        
        shareBtn.addEventListener('click', () => {
            let text;
            if (modalTitle.textContent.includes("Victory")) {
                text = "I just won in siCHESS and earned 520 ORANGES! ð #siCHESS";
            } else {
                text = "siCHESS beat me, but I'll be back! ð #siCHESS";
            }
            
            const url = "https://twitter.com/intent/tweet?text=" + encodeURIComponent(text);
            window.open(url, '_blank');
        });
        
        // Start the game on medium difficulty by default
        document.querySelector('.difficulty-btn[data-difficulty="medium"]').classList.add('active');
        startGame();
    </script>
</body>
</html>
