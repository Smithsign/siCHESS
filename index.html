<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>siCHESS - Orange Themed Chess</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.2/chess.js"></script>
    <style>
        :root {
            --orange-light: #ffb347;
            --orange-med: #ff8c00;
            --orange-dark: #ff6b00;
            --white: #ffffff;
            --black: #222222;
            --highlight: rgba(255, 140, 0, 0.5);
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #fff8f0, #ffe8d1);
            margin: 0;
            padding: 20px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            color: var(--black);
        }
        
        h1 {
            color: var(--orange-dark);
            text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
            margin-bottom: 10px;
        }
        
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            width: 100%;
            max-width: 800px;
        }
        
        .menu-screen {
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        
        .difficulty-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .difficulty-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 25px;
            background: linear-gradient(to right, var(--orange-light), var(--orange-med));
            color: white;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(255, 140, 0, 0.2);
            transition: all 0.3s;
        }
        
        .difficulty-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(255, 140, 0, 0.3);
        }
        
        .difficulty-btn.active {
            background: linear-gradient(to right, var(--orange-med), var(--orange-dark));
            box-shadow: 0 4px 8px rgba(255, 107, 0, 0.3);
        }
        
        .start-btn {
            padding: 12px 30px;
            border: none;
            border-radius: 25px;
            background: linear-gradient(to right, var(--orange-med), var(--orange-dark));
            color: white;
            font-weight: bold;
            font-size: 1.2rem;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(255, 107, 0, 0.3);
            transition: all 0.3s;
        }
        
        .start-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(255, 107, 0, 0.4);
        }
        
        .board-container {
            position: relative;
            width: 100%;
            max-width: 500px;
            aspect-ratio: 1/1;
            box-shadow: 0 10px 20px rgba(0,0,0,0.1);
            border-radius: 8px;
            overflow: hidden;
            display: none;
        }
        
        #board {
            width: 100%;
            height: 100%;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
        }
        
        .square {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
        }
        
        .white {
            background-color: var(--white);
        }
        
        .black {
            background-color: var(--orange-light);
        }
        
        .piece {
            width: 80%;
            height: 80%;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            z-index: 10;
        }
        
        .selected {
            background-color: var(--highlight);
        }
        
        .valid-move {
            position: absolute;
            width: 30%;
            height: 30%;
            background-color: var(--highlight);
            border-radius: 50%;
            z-index: 5;
        }
        
        .capture-move {
            position: absolute;
            width: 80%;
            height: 80%;
            border: 4px solid var(--highlight);
            border-radius: 50%;
            box-sizing: border-box;
            z-index: 5;
        }
        
        .timer-container {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 500px;
            display: none;
        }
        
        .timer {
            background: linear-gradient(to right, var(--orange-light), var(--orange-med));
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 1.2rem;
            font-weight: bold;
            box-shadow: 0 4px 8px rgba(255, 140, 0, 0.2);
            min-width: 100px;
            text-align: center;
        }
        
        .timer.low-time {
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0% { background: linear-gradient(to right, var(--orange-light), var(--orange-med)); }
            50% { background: linear-gradient(to right, #ff5e5e, #ff0000); }
            100% { background: linear-gradient(to right, var(--orange-light), var(--orange-med)); }
        }
        
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }
        
        .modal.active {
            opacity: 1;
            pointer-events: all;
        }
        
        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            max-width: 400px;
            width: 90%;
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
            transform: translateY(-20px);
            transition: transform 0.3s;
        }
        
        .modal.active .modal-content {
            transform: translateY(0);
        }
        
        .modal h2 {
            color: var(--orange-dark);
            margin-bottom: 20px;
        }
        
        .modal p {
            margin-bottom: 25px;
            font-size: 1.1rem;
        }
        
        .modal-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
        }
        
        .modal-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 25px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .primary-btn {
            background: linear-gradient(to right, var(--orange-light), var(--orange-med));
            color: white;
        }
        
        .secondary-btn {
            background: #f0f0f0;
            color: var(--black);
        }
        
        .modal-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        
        @media (max-width: 600px) {
            .difficulty-selector {
                flex-direction: column;
                width: 100%;
            }
            
            .difficulty-btn {
                width: 100%;
            }
            
            .timer-container {
                flex-direction: column;
                gap: 10px;
            }
            
            .timer {
                width: 100%;
                box-sizing: border-box;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>siCHESS üçä</h1>
        
        <div class="menu-screen" id="menu-screen">
            <h2>Select Difficulty</h2>
            <div class="difficulty-selector">
                <button class="difficulty-btn" data-difficulty="easy">Easy</button>
                <button class="difficulty-btn" data-difficulty="medium">Medium</button>
                <button class="difficulty-btn" data-difficulty="extreme">Extreme</button>
            </div>
            <button class="start-btn" id="start-btn">Start Game</button>
        </div>
        
        <div class="board-container" id="board-container">
            <div id="board"></div>
        </div>
        
        <div class="timer-container" id="timer-container">
            <div class="timer" id="player-timer">5:00</div>
            <div class="timer" id="ai-timer">5:00</div>
        </div>
    </div>
    
    <div class="modal" id="game-over-modal">
        <div class="modal-content">
            <h2 id="modal-title">Game Over</h2>
            <p id="modal-message"></p>
            <div class="modal-buttons">
                <button class="modal-btn primary-btn" id="try-again-btn">Try Again</button>
                <button class="modal-btn secondary-btn" id="share-btn">Share on X</button>
            </div>
        </div>
    </div>
    
    <script>
        // Game state
        let game = new Chess();
        let selectedSquare = null;
        let validMoves = [];
        let difficulty = 'medium';
        let playerTime = 5 * 60;
        let aiTime = 5 * 60;
        let playerTimerInterval = null;
        let aiTimerInterval = null;
        let isPlayerTurn = true;
        let gameActive = false;
        
        // DOM elements
        const boardElement = document.getElementById('board');
        const playerTimerElement = document.getElementById('player-timer');
        const aiTimerElement = document.getElementById('ai-timer');
        const difficultyButtons = document.querySelectorAll('.difficulty-btn');
        const startBtn = document.getElementById('start-btn');
        const menuScreen = document.getElementById('menu-screen');
        const boardContainer = document.getElementById('board-container');
        const timerContainer = document.getElementById('timer-container');
        const gameOverModal = document.getElementById('game-over-modal');
        const modalTitle = document.getElementById('modal-title');
        const modalMessage = document.getElementById('modal-message');
        const tryAgainBtn = document.getElementById('try-again-btn');
        const shareBtn = document.getElementById('share-btn');
        
        // Initialize the board
        function initBoard() {
            boardElement.innerHTML = '';
            
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    const square = document.createElement('div');
                    square.className = `square ${(i + j) % 2 === 0 ? 'white' : 'black'}`;
                    square.dataset.row = i;
                    square.dataset.col = j;
                    square.dataset.square = `${String.fromCharCode(97 + j)}${8 - i}`;
                    
                    square.addEventListener('click', () => handleSquareClick(square));
                    
                    boardElement.appendChild(square);
                }
            }
            
            updateBoard();
        }
        
        // Update the board display
        function updateBoard() {
            document.querySelectorAll('.selected, .valid-move, .capture-move').forEach(el => {
                el.classList.remove('selected', 'valid-move', 'capture-move');
                const moveIndicator = el.querySelector('.valid-move, .capture-move');
                if (moveIndicator) el.removeChild(moveIndicator);
            });
            
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    const squareNotation = `${String.fromCharCode(97 + j)}${8 - i}`;
                    const piece = game.get(squareNotation);
                    const squareElement = document.querySelector(`[data-square="${squareNotation}"]`);
                    
                    const existingPiece = squareElement.querySelector('.piece');
                    if (existingPiece) squareElement.removeChild(existingPiece);
                    
                    if (piece) {
                        const pieceElement = document.createElement('div');
                        pieceElement.className = 'piece';
                        pieceElement.style.backgroundImage = `url('https://images.chesscomfiles.com/chess-themes/pieces/neo/150/${piece.color}${piece.type}.png')`;
                        squareElement.appendChild(pieceElement);
                    }
                }
            }
            
            if (selectedSquare) {
                const squareElement = document.querySelector(`[data-square="${selectedSquare}"]`);
                if (squareElement) {
                    squareElement.classList.add('selected');
                    
                    validMoves.forEach(move => {
                        if (move.from === selectedSquare) {
                            const targetSquare = document.querySelector(`[data-square="${move.to}"]`);
                            if (targetSquare) {
                                const moveIndicator = document.createElement('div');
                                moveIndicator.className = game.get(move.to) ? 'capture-move' : 'valid-move';
                                targetSquare.appendChild(moveIndicator);
                            }
                        }
                    });
                }
            }
        }
        
        // Handle square clicks
        function handleSquareClick(squareElement) {
            if (!gameActive || !isPlayerTurn) return;
            
            const square = squareElement.dataset.square;
            const piece = game.get(square);
            
            if (!selectedSquare && piece && piece.color === 'w') {
                selectedSquare = square;
                validMoves = game.moves({square: square, verbose: true});
                updateBoard();
                return;
            }
            
            if (selectedSquare) {
                if (square === selectedSquare) {
                    selectedSquare = null;
                    validMoves = [];
                    updateBoard();
                    return;
                }
                
                if (piece && piece.color === 'w') {
                    selectedSquare = square;
                    validMoves = game.moves({square: square, verbose: true});
                    updateBoard();
                    return;
                }
                
                const move = validMoves.find(m => m.to === square);
                if (move) makeMove(move);
            }
        }
        
        // Make a move
        function makeMove(move) {
            if (isPlayerTurn) stopPlayerTimer();
            else stopAITimer();

            game.move(move);
            selectedSquare = null;
            validMoves = [];
            updateBoard();

            if (game.isGameOver()) {
                endGame();
                return;
            }

            isPlayerTurn = !isPlayerTurn;

            if (isPlayerTurn) {
                startPlayerTimer();
            } else {
                startAITimer();
                // Process AI move on the next animation frame for immediate response
                requestAnimationFrame(makeAIMove);
            }
        }

        // Fast AI move logic
        function makeAIMove() {
            if (!gameActive || isPlayerTurn) return;

            let move;
            const moves = game.moves({verbose: true});
            
            if (moves.length === 0) return;

            if (difficulty === 'easy') {
                // Random moves (fastest)
                move = moves[Math.floor(Math.random() * moves.length)].san;
            } 
            else if (difficulty === 'medium') {
                // Prefer captures and safe moves
                const captures = moves.filter(m => m.captured);
                if (captures.length > 0) {
                    // Prefer higher value captures
                    captures.sort((a, b) => getPieceValue(b.captured) - getPieceValue(a.captured));
                    move = captures[0].san;
                } else {
                    // Safe moves that don't immediately lose material
                    const safeMoves = moves.filter(m => {
                        const testGame = new Chess(game.fen());
                        testGame.move(m);
                        return !testGame.isCheckmate();
                    });
                    move = safeMoves.length > 0 
                        ? safeMoves[Math.floor(Math.random() * safeMoves.length)].san
                        : moves[Math.floor(Math.random() * moves.length)].san;
                }
            } 
            else {
                // Extreme: Quick minimax with depth 2
                move = findBestMoveQuick(2);
            }

            if (move) makeMove(move);
        }

        // Optimized minimax for extreme difficulty
        function findBestMoveQuick(depth) {
            const moves = game.moves({verbose: true});
            let bestMove = moves[0];
            let bestValue = -Infinity;
            
            for (let i = 0; i < moves.length; i++) {
                const testGame = new Chess(game.fen());
                testGame.move(moves[i]);
                
                let value = quickEvaluate(testGame);
                
                if (depth > 0) {
                    const opponentMoves = testGame.moves({verbose: true});
                    let minOpponentValue = Infinity;
                    
                    // Only check top 3 opponent responses for speed
                    for (let j = 0; j < Math.min(3, opponentMoves.length); j++) {
                        const testGame2 = new Chess(testGame.fen());
                        testGame2.move(opponentMoves[j]);
                        const opponentValue = quickEvaluate(testGame2);
                        minOpponentValue = Math.min(minOpponentValue, opponentValue);
                    }
                    
                    value = minOpponentValue;
                }
                
                if (value > bestValue) {
                    bestValue = value;
                    bestMove = moves[i];
                }
            }
            
            return bestMove.san;
        }

        // Quick board evaluation
        function quickEvaluate(game) {
            if (game.isCheckmate()) return game.turn() === 'w' ? -1000 : 1000;
            if (game.isDraw()) return 0;
            
            let score = 0;
            const pieceValues = {'p':1,'n':3,'b':3,'r':5,'q':9,'k':0};
            const board = game.board();
            
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    const piece = board[i][j];
                    if (piece) {
                        score += piece.color === 'w' ? pieceValues[piece.type] : -pieceValues[piece.type];
                    }
                }
            }
            return score;
        }

        // Piece values
        function getPieceValue(pieceType) {
            return {'p':1,'n':3,'b':3,'r':5,'q':9,'k':0}[pieceType] || 0;
        }

        // Timer functions
        function startPlayerTimer() {
            stopPlayerTimer();
            playerTimerInterval = setInterval(() => {
                playerTime--;
                updateTimers();
                if (playerTime <= 0) {
                    stopPlayerTimer();
                    endGame(false);
                }
                if (playerTime <= 30) playerTimerElement.classList.add('low-time');
            }, 1000);
        }
        
        function stopPlayerTimer() {
            if (playerTimerInterval) {
                clearInterval(playerTimerInterval);
                playerTimerInterval = null;
            }
            playerTimerElement.classList.remove('low-time');
        }
        
        function startAITimer() {
            stopAITimer();
            aiTimerInterval = setInterval(() => {
                aiTime--;
                updateTimers();
                if (aiTime <= 0) {
                    stopAITimer();
                    endGame(true);
                }
            }, 1000);
        }
        
        function stopAITimer() {
            if (aiTimerInterval) {
                clearInterval(aiTimerInterval);
                aiTimerInterval = null;
            }
        }
        
        function updateTimers() {
            const playerMinutes = Math.floor(playerTime / 60);
            const playerSeconds = playerTime % 60;
            playerTimerElement.textContent = `${playerMinutes}:${playerSeconds.toString().padStart(2, '0')}`;
            
            const aiMinutes = Math.floor(aiTime / 60);
            const aiSeconds = aiTime % 60;
            aiTimerElement.textContent = `${aiMinutes}:${aiSeconds.toString().padStart(2, '0')}`;
        }
        
        // Game control
        function startGame() {
            game = new Chess();
            selectedSquare = null;
            validMoves = [];
            playerTime = 5 * 60;
            aiTime = 5 * 60;
            isPlayerTurn = true;
            gameActive = true;
            
            menuScreen.style.display = 'none';
            boardContainer.style.display = 'block';
            timerContainer.style.display = 'flex';
            
            updateTimers();
            initBoard();
            startPlayerTimer();
        }
        
        function endGame(playerWon = null) {
            gameActive = false;
            stopPlayerTimer();
            stopAITimer();
            
            if (playerWon === null) {
                if (game.isCheckmate()) {
                    playerWon = game.turn() === 'b';
                } else {
                    modalTitle.textContent = "Game Drawn";
                    modalMessage.textContent = "The game ended in a draw. Try again!";
                }
            }
            
            if (playerWon !== null) {
                if (playerWon) {
                    modalTitle.textContent = "Victory!";
                    modalMessage.textContent = "üéâ You won and earned 520 ORANGES! üçä";
                } else {
                    modalTitle.textContent = "Game Over";
                    modalMessage.textContent = "Time's up! Try again and claim those ORANGES!";
                }
            }
            
            gameOverModal.classList.add('active');
        }

        // Event listeners
        difficultyButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                difficultyButtons.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                difficulty = btn.dataset.difficulty;
            });
        });
        
        startBtn.addEventListener('click', startGame);
        tryAgainBtn.addEventListener('click', () => {
            gameOverModal.classList.remove('active');
            startGame();
        });
        
        shareBtn.addEventListener('click', () => {
            const text = modalTitle.textContent.includes("Victory") 
                ? "I just won in siCHESS and earned 520 ORANGES! üçä #siCHESS"
                : "siCHESS beat me, but I'll be back! üçä #siCHESS";
            window.open(`https://twitter.com/intent/tweet?text=${encodeURIComponent(text)}`, '_blank');
        });

        // Initialize with medium difficulty selected
        document.querySelector('.difficulty-btn[data-difficulty="medium"]').classList.add('active');
    </script>
</body>
</html>
